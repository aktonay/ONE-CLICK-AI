#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ {{ project_name }} â€” ONE-COMMAND DEPLOY
# Generated by one-click-ai (ocd-ai)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
set -eo pipefail

# â”€â”€ Colors â”€â”€
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; NC='\033[0m'

PROJECT="{{ project_name }}"
IMAGE_NAME="{{ dockerhub_username | default('user', true) }}/${PROJECT}"
COMPOSE_PROD="docker-compose.prod.yml"

# â”€â”€ Helpers â”€â”€
info()    { echo -e "${BLUE}â„¹ ${NC}$*"; }
success() { echo -e "${GREEN}âœ… $*${NC}"; }
warn()    { echo -e "${YELLOW}âš  $*${NC}"; }
error()   { echo -e "${RED}âŒ $*${NC}"; exit 1; }
banner()  {
    echo ""
    echo -e "${CYAN}${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}${BOLD}â•‘   ğŸš€ ${PROJECT} â€” Deploy Wizard              â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•‘   Generated by one-click-ai                 â•‘${NC}"
    echo -e "${CYAN}${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

check_command() {
    if ! command -v "$1" &>/dev/null; then
        error "$1 is required but not installed. Install it first."
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# GIT: Stage, commit, push
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
git_push() {
    info "Pushing code to GitHub..."
    check_command git

    if [ ! -d ".git" ]; then
        git init
        git branch -M main
    fi

    # Ensure remote exists
    {% if github_repository_url %}
    REMOTE_URL="{{ github_repository_url }}"
    if ! git remote get-url origin &>/dev/null; then
        git remote add origin "$REMOTE_URL"
    fi
    {% else %}
    if ! git remote get-url origin &>/dev/null; then
        read -rp "Enter GitHub repository URL: " REMOTE_URL
        git remote add origin "$REMOTE_URL"
    fi
    {% endif %}

    git add -A
    COMMIT_MSG="${1:-deploy: $(date +%Y-%m-%d_%H:%M:%S)}"
    git commit -m "$COMMIT_MSG" 2>/dev/null || info "Nothing new to commit"
    git push -u origin main
    success "Code pushed to GitHub!"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DOCKER: Build & push image
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
docker_build_push() {
    info "Building & pushing Docker image..."
    check_command docker

    TAG="${1:-latest}"

    docker build -t "${IMAGE_NAME}:${TAG}" -f backend/Dockerfile backend/
    docker tag "${IMAGE_NAME}:${TAG}" "${IMAGE_NAME}:latest"

    # Try GHCR first, fall back to DockerHub
    if echo "${IMAGE_NAME}" | grep -q "ghcr.io"; then
        docker push "${IMAGE_NAME}:${TAG}"
        docker push "${IMAGE_NAME}:latest"
    else
        docker push "${IMAGE_NAME}:${TAG}" 2>/dev/null || {
            warn "DockerHub push failed. Trying GitHub Container Registry..."
            GHCR="ghcr.io/{{ github_username | default('user', true) }}/${PROJECT}"
            docker tag "${IMAGE_NAME}:${TAG}" "${GHCR}:${TAG}"
            docker push "${GHCR}:${TAG}"
        }
    fi
    success "Docker image pushed: ${IMAGE_NAME}:${TAG}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: AWS (ECS Fargate / EC2)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_aws() {
    info "Deploying to AWS..."
    check_command aws

    echo ""
    echo -e "${BOLD}AWS Deployment Options:${NC}"
    echo "  1) ECS Fargate   (serverless containers â€” recommended)"
    echo "  2) EC2 + Docker  (traditional VM)"
    echo "  3) App Runner    (simplest â€” auto-scaling)"
    echo ""
    read -rp "Choose [1/2/3]: " AWS_CHOICE

    case $AWS_CHOICE in
        1) deploy_aws_ecs ;;
        2) deploy_aws_ec2 ;;
        3) deploy_aws_apprunner ;;
        *) deploy_aws_ecs ;;
    esac
}

deploy_aws_ecs() {
    info "Deploying to ECS Fargate..."
    REGION="${AWS_REGION:-us-east-1}"
    CLUSTER="${PROJECT}-cluster"
    SERVICE="${PROJECT}-service"

    # Create ECR repo if not exists
    aws ecr describe-repositories --repository-names "$PROJECT" --region "$REGION" 2>/dev/null || \
        aws ecr create-repository --repository-name "$PROJECT" --region "$REGION"

    # Login to ECR
    ECR_URI=$(aws ecr describe-repositories --repository-names "$PROJECT" --region "$REGION" \
        --query 'repositories[0].repositoryUri' --output text)
    aws ecr get-login-password --region "$REGION" | docker login --username AWS --password-stdin "${ECR_URI%%/*}"

    # Build & push to ECR
    docker build -t "${ECR_URI}:latest" -f backend/Dockerfile backend/
    docker push "${ECR_URI}:latest"

    # Create cluster if not exists
    aws ecs describe-clusters --clusters "$CLUSTER" --region "$REGION" \
        --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE || \
        aws ecs create-cluster --cluster-name "$CLUSTER" --region "$REGION"

    # Register/update task definition
    cat > /tmp/task-def.json <<EOF
{
    "family": "${PROJECT}",
    "networkMode": "awsvpc",
    "requiresCompatibilities": ["FARGATE"],
    "cpu": "512",
    "memory": "1024",
    "executionRoleArn": "arn:aws:iam::role/ecsTaskExecutionRole",
    "containerDefinitions": [{
        "name": "${PROJECT}",
        "image": "${ECR_URI}:latest",
        "portMappings": [{"containerPort": 8000, "protocol": "tcp"}],
        "essential": true,
        "logConfiguration": {
            "logDriver": "awslogs",
            "options": {
                "awslogs-group": "/ecs/${PROJECT}",
                "awslogs-region": "${REGION}",
                "awslogs-stream-prefix": "ecs"
            }
        }
    }]
}
EOF
    aws ecs register-task-definition --cli-input-json file:///tmp/task-def.json --region "$REGION"

    # Update or create service
    aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --region "$REGION" \
        --query 'services[0].status' --output text 2>/dev/null | grep -q ACTIVE && {
        aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" \
            --force-new-deployment --region "$REGION"
    } || {
        warn "ECS service doesn't exist. Create it via AWS Console or Terraform (infra/terraform/)."
        info "Run: cd infra/terraform && terraform apply"
    }
    success "AWS ECS deployment triggered!"
}

deploy_aws_ec2() {
    {% if iac %}
    info "Deploying to EC2 with Terraform + Ansible..."
    if [ -d "infra/terraform" ]; then
        cd infra/terraform
        terraform init -input=false
        terraform apply -auto-approve
        SERVER_IP=$(terraform output -raw public_ip)
        cd ../..

        info "Configuring server at $SERVER_IP..."
        if [ -d "infra/ansible" ]; then
            echo "[servers]" > infra/ansible/hosts.ini
            echo "$SERVER_IP ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa" >> infra/ansible/hosts.ini
            cd infra/ansible
            ansible-playbook -i hosts.ini playbook.yml
            cd ../..
        fi
        success "Deployed to EC2: http://$SERVER_IP"
    else
        error "No infra/terraform directory. Run: ocd-ai init --iac to generate IaC templates."
    fi
    {% else %}
    warn "IaC templates not generated. Re-generate project with --iac flag."
    warn "Or run: ocd-ai init . --iac"
    {% endif %}
}

deploy_aws_apprunner() {
    info "Deploying to AWS App Runner..."
    REGION="${AWS_REGION:-us-east-1}"

    # Push to ECR first
    deploy_aws_ecs  # reuses ECR push logic

    ECR_URI=$(aws ecr describe-repositories --repository-names "$PROJECT" --region "$REGION" \
        --query 'repositories[0].repositoryUri' --output text)

    aws apprunner create-service \
        --service-name "$PROJECT" \
        --source-configuration "{
            \"ImageRepository\": {
                \"ImageIdentifier\": \"${ECR_URI}:latest\",
                \"ImageRepositoryType\": \"ECR\",
                \"ImageConfiguration\": {\"Port\": \"8000\"}
            },
            \"AutoDeploymentsEnabled\": true
        }" \
        --instance-configuration '{"Cpu": "1024", "Memory": "2048"}' \
        --region "$REGION" 2>/dev/null || {
        aws apprunner update-service --service-arn \
            "$(aws apprunner list-services --region $REGION --query "ServiceSummaryList[?ServiceName=='$PROJECT'].ServiceArn" --output text)" \
            --source-configuration "{
                \"ImageRepository\": {
                    \"ImageIdentifier\": \"${ECR_URI}:latest\",
                    \"ImageRepositoryType\": \"ECR\",
                    \"ImageConfiguration\": {\"Port\": \"8000\"}
                }
            }" --region "$REGION"
    }
    success "AWS App Runner deployment triggered!"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: Azure (Container Apps)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_azure() {
    info "Deploying to Azure Container Apps..."
    check_command az

    RESOURCE_GROUP="${PROJECT}-rg"
    LOCATION="${AZURE_LOCATION:-eastus}"
    ACR_NAME="${PROJECT//[^a-zA-Z0-9]/}acr"
    CA_ENV="${PROJECT}-env"

    # Login
    az account show &>/dev/null || az login

    # Create resource group
    az group create --name "$RESOURCE_GROUP" --location "$LOCATION" -o none

    # Create ACR
    az acr create --resource-group "$RESOURCE_GROUP" --name "$ACR_NAME" --sku Basic -o none 2>/dev/null || true
    az acr login --name "$ACR_NAME"

    # Build & push
    ACR_SERVER="${ACR_NAME}.azurecr.io"
    docker build -t "${ACR_SERVER}/${PROJECT}:latest" -f backend/Dockerfile backend/
    docker push "${ACR_SERVER}/${PROJECT}:latest"

    # Create Container Apps environment
    az containerapp env create \
        --name "$CA_ENV" \
        --resource-group "$RESOURCE_GROUP" \
        --location "$LOCATION" -o none 2>/dev/null || true

    # Enable admin on ACR for Container Apps
    az acr update -n "$ACR_NAME" --admin-enabled true -o none
    ACR_PASSWORD=$(az acr credential show -n "$ACR_NAME" --query "passwords[0].value" -o tsv)

    # Deploy / update container app
    az containerapp create \
        --name "$PROJECT" \
        --resource-group "$RESOURCE_GROUP" \
        --environment "$CA_ENV" \
        --image "${ACR_SERVER}/${PROJECT}:latest" \
        --target-port 8000 \
        --ingress external \
        --registry-server "$ACR_SERVER" \
        --registry-username "$ACR_NAME" \
        --registry-password "$ACR_PASSWORD" \
        --cpu 0.5 --memory 1.0Gi \
        --min-replicas 1 --max-replicas 10 \
        -o none 2>/dev/null || \
    az containerapp update \
        --name "$PROJECT" \
        --resource-group "$RESOURCE_GROUP" \
        --image "${ACR_SERVER}/${PROJECT}:latest" -o none

    FQDN=$(az containerapp show --name "$PROJECT" --resource-group "$RESOURCE_GROUP" \
        --query "properties.configuration.ingress.fqdn" -o tsv)
    success "Deployed to Azure: https://${FQDN}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: DigitalOcean (App Platform / Droplet)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_digitalocean() {
    info "Deploying to DigitalOcean..."
    check_command doctl

    echo ""
    echo -e "${BOLD}DigitalOcean Options:${NC}"
    echo "  1) App Platform  (managed â€” recommended)"
    echo "  2) Droplet + Docker"
    echo ""
    read -rp "Choose [1/2]: " DO_CHOICE

    case $DO_CHOICE in
        1) deploy_do_app_platform ;;
        2) deploy_do_droplet ;;
        *) deploy_do_app_platform ;;
    esac
}

deploy_do_app_platform() {
    info "Deploying to DO App Platform..."

    # Create app spec
    cat > /tmp/do-app-spec.yaml <<EOF
name: ${PROJECT}
services:
  - name: ${PROJECT}
    dockerfile_path: backend/Dockerfile
    github:
      repo: {{ github_username | default('user', true) }}/${PROJECT}
      branch: main
      deploy_on_push: true
    http_port: 8000
    instance_count: 1
    instance_size_slug: basic-xxs
    routes:
      - path: /
{% if postgres %}
databases:
  - engine: PG
    name: db
    production: false
    version: "16"
{% endif %}
{% if redis %}
  - engine: REDIS
    name: cache
    production: false
    version: "7"
{% endif %}
EOF

    doctl apps create --spec /tmp/do-app-spec.yaml --format ID --no-header || \
        warn "App may already exist. Updating..."

    APP_ID=$(doctl apps list --format ID,Spec.Name --no-header | grep "$PROJECT" | awk '{print $1}')
    if [ -n "$APP_ID" ]; then
        doctl apps update "$APP_ID" --spec /tmp/do-app-spec.yaml
        URL=$(doctl apps get "$APP_ID" --format DefaultIngress --no-header)
        success "Deployed to DigitalOcean: ${URL}"
    fi
}

deploy_do_droplet() {
    info "Deploying to DO Droplet..."
    REGION="${DO_REGION:-nyc3}"
    DROPLET_NAME="${PROJECT}-server"

    # Check if droplet exists
    DROPLET_IP=$(doctl compute droplet list --format Name,PublicIPv4 --no-header | grep "$DROPLET_NAME" | awk '{print $2}')

    if [ -z "$DROPLET_IP" ]; then
        info "Creating new droplet..."
        doctl compute droplet create "$DROPLET_NAME" \
            --size s-2vcpu-4gb \
            --image docker-20-04 \
            --region "$REGION" \
            --ssh-keys "$(doctl compute ssh-key list --format ID --no-header | head -1)" \
            --wait

        DROPLET_IP=$(doctl compute droplet get "$DROPLET_NAME" --format PublicIPv4 --no-header)
        info "Waiting for droplet to be ready..."
        sleep 30
    fi

    info "Deploying to $DROPLET_IP..."
    ssh -o StrictHostKeyChecking=no "root@${DROPLET_IP}" << REMOTE
        mkdir -p /opt/${PROJECT}
        cd /opt/${PROJECT}
        git clone {{ github_repository_url | default('https://github.com/' + github_username|default('user',true) + '/' + project_name + '.git', true) }} . 2>/dev/null || git pull
        docker compose -f docker-compose.prod.yml up -d --build
REMOTE
    success "Deployed to DigitalOcean Droplet: http://${DROPLET_IP}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: GCP (Cloud Run)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_gcp() {
    info "Deploying to Google Cloud Run..."
    check_command gcloud

    GCP_PROJECT="${GCP_PROJECT_ID:-$(gcloud config get-value project)}"
    REGION="${GCP_REGION:-us-central1}"

    # Enable required APIs
    gcloud services enable run.googleapis.com artifactregistry.googleapis.com --project="$GCP_PROJECT"

    # Create Artifact Registry repo
    gcloud artifacts repositories create "$PROJECT" \
        --repository-format=docker \
        --location="$REGION" \
        --project="$GCP_PROJECT" 2>/dev/null || true

    # Build & push
    AR_IMAGE="${REGION}-docker.pkg.dev/${GCP_PROJECT}/${PROJECT}/${PROJECT}:latest"
    gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet
    docker build -t "$AR_IMAGE" -f backend/Dockerfile backend/
    docker push "$AR_IMAGE"

    # Deploy to Cloud Run
    gcloud run deploy "$PROJECT" \
        --image "$AR_IMAGE" \
        --platform managed \
        --region "$REGION" \
        --port 8000 \
        --allow-unauthenticated \
        --memory 1Gi \
        --cpu 1 \
        --min-instances 0 \
        --max-instances 10 \
        --project "$GCP_PROJECT"

    URL=$(gcloud run services describe "$PROJECT" --region "$REGION" --project "$GCP_PROJECT" --format='value(status.url)')
    success "Deployed to GCP Cloud Run: ${URL}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: Railway (easiest deploy)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_railway() {
    info "Deploying to Railway..."
    check_command railway

    railway login 2>/dev/null || true
    railway init 2>/dev/null || true
    railway up --detach
    railway open
    success "Deployed to Railway!"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: Fly.io
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_fly() {
    info "Deploying to Fly.io..."
    check_command flyctl

    if [ ! -f "fly.toml" ]; then
        flyctl launch --name "$PROJECT" \
            --dockerfile backend/Dockerfile \
            --internal-port 8000 \
            --region iad \
            --no-deploy --yes
    fi

    flyctl deploy
    flyctl open
    success "Deployed to Fly.io!"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PLATFORM: Render.com
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_render() {
    info "Deploying to Render..."

    if [ ! -f "render.yaml" ]; then
        cat > render.yaml <<EOF
services:
  - type: web
    name: ${PROJECT}
    runtime: docker
    dockerfilePath: ./backend/Dockerfile
    dockerContext: ./backend
    envVars:
      - key: PORT
        value: 8000
{% if postgres %}
databases:
  - name: ${PROJECT}-db
    plan: free
    databaseName: ${PROJECT}
{% endif %}
{% if redis %}
  - type: redis
    name: ${PROJECT}-cache
    plan: free
{% endif %}
EOF
        success "Created render.yaml"
    fi

    warn "Render.com deploys via Git push. Ensure your repo is connected at https://render.com"
    git_push "deploy: render $(date +%Y-%m-%d)"
    success "Pushed to GitHub â€” Render will auto-deploy!"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FULL DEPLOY: git push â†’ build â†’ deploy to chosen platform
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
full_deploy() {
    banner

    echo -e "${BOLD}Choose deployment platform:${NC}"
    echo ""
    echo -e "  ${GREEN}1)${NC} AWS           (ECS Fargate / EC2 / App Runner)"
    echo -e "  ${GREEN}2)${NC} Azure         (Container Apps)"
    echo -e "  ${GREEN}3)${NC} DigitalOcean  (App Platform / Droplet)"
    echo -e "  ${GREEN}4)${NC} GCP           (Cloud Run)"
    echo -e "  ${GREEN}5)${NC} Railway       (easiest â€” recommended for quick start)"
    echo -e "  ${GREEN}6)${NC} Fly.io        (global edge deployment)"
    echo -e "  ${GREEN}7)${NC} Render        (git-push deploy)"
    echo -e "  ${GREEN}8)${NC} Self-hosted   (your own server via Docker)"
    echo ""
    read -rp "Select platform [1-8]: " PLATFORM

    echo ""
    info "Step 1/3: Pushing code to GitHub..."
    git_push "deploy: $(date +%Y-%m-%d_%H:%M:%S)"

    echo ""
    info "Step 2/3: Building Docker image..."
    docker_build_push "$(git rev-parse --short HEAD 2>/dev/null || echo latest)"

    echo ""
    info "Step 3/3: Deploying to platform..."
    case $PLATFORM in
        1) deploy_aws ;;
        2) deploy_azure ;;
        3) deploy_digitalocean ;;
        4) deploy_gcp ;;
        5) deploy_railway ;;
        6) deploy_fly ;;
        7) deploy_render ;;
        8) deploy_self_hosted ;;
        *) error "Invalid choice" ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SELF-HOSTED: Deploy via SSH + Docker Compose
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
deploy_self_hosted() {
    read -rp "Server IP/hostname: " SERVER_HOST
    read -rp "SSH user [root]: " SERVER_USER
    SERVER_USER="${SERVER_USER:-root}"

    info "Deploying to ${SERVER_USER}@${SERVER_HOST}..."

    ssh -o StrictHostKeyChecking=no "${SERVER_USER}@${SERVER_HOST}" << REMOTE
        set -e
        # Install Docker if missing
        if ! command -v docker &>/dev/null; then
            curl -fsSL https://get.docker.com | sh
        fi
        mkdir -p /opt/${PROJECT}
        cd /opt/${PROJECT}
        git clone {{ github_repository_url | default('https://github.com/' + github_username|default('user',true) + '/' + project_name + '.git', true) }} . 2>/dev/null || git pull origin main
        docker compose -f docker-compose.prod.yml pull 2>/dev/null || true
        docker compose -f docker-compose.prod.yml up -d --build
        echo "Health check..."
        sleep 5
        curl -sf http://localhost:8000/api/v1/health || echo "App starting up..."
REMOTE
    success "Deployed to ${SERVER_HOST}!"
    echo -e "  ğŸŒ URL: http://${SERVER_HOST}"
    echo -e "  ğŸ“ API: http://${SERVER_HOST}/docs"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Quick commands
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
show_help() {
    banner
    echo "Usage: ./deploy.sh [command]"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo "  deploy       Full deploy wizard (git push â†’ build â†’ deploy)"
    echo "  push         Git add, commit, push to GitHub"
    echo "  build        Build & push Docker image"
    echo "  aws          Deploy to AWS"
    echo "  azure        Deploy to Azure"
    echo "  do           Deploy to DigitalOcean"
    echo "  gcp          Deploy to Google Cloud"
    echo "  railway      Deploy to Railway"
    echo "  fly          Deploy to Fly.io"
    echo "  render       Deploy to Render"
    echo "  server       Deploy to self-hosted server"
    echo "  status       Check deployment health"
    echo "  help         Show this help"
    echo ""
    echo -e "${BOLD}Quick deploy (one command):${NC}"
    echo "  ./deploy.sh deploy"
    echo ""
    echo -e "${BOLD}Environment variables:${NC}"
    echo "  AWS_REGION          AWS region (default: us-east-1)"
    echo "  AZURE_LOCATION      Azure location (default: eastus)"
    echo "  GCP_PROJECT_ID      GCP project ID"
    echo "  GCP_REGION          GCP region (default: us-central1)"
    echo "  DO_REGION           DigitalOcean region (default: nyc3)"
    echo ""
}

check_status() {
    info "Checking deployment health..."
    {% if github_repository_url %}
    echo -e "  GitHub: {{ github_repository_url }}"
    {% endif %}
    echo -e "  Local:  http://localhost:8000/docs"

    # Check local
    if curl -sf http://localhost:8000/api/v1/health &>/dev/null; then
        success "Local service is healthy"
    else
        warn "Local service is not running"
    fi
}

# â”€â”€ Main â”€â”€
case "${1:-deploy}" in
    deploy)      full_deploy ;;
    push)        git_push "${2}" ;;
    build)       docker_build_push "${2:-latest}" ;;
    aws)         deploy_aws ;;
    azure)       deploy_azure ;;
    do)          deploy_digitalocean ;;
    gcp)         deploy_gcp ;;
    railway)     deploy_railway ;;
    fly)         deploy_fly ;;
    render)      deploy_render ;;
    server)      deploy_self_hosted ;;
    status)      check_status ;;
    help|--help) show_help ;;
    *)           show_help ;;
esac
