"""Emotion detection from audio and text."""

from typing import Dict
from app.config import get_settings
import logging

logger = logging.getLogger(__name__)


class EmotionClient:
    """Emotion detection — Hume AI, or LLM-based fallback."""

    def __init__(self):
        self.settings = get_settings()
        self.provider = self.settings.EMOTION_PROVIDER

    async def analyze_audio(self, audio_bytes: bytes) -> Dict:
        """Detect emotion from audio prosody."""
        if self.provider == "hume":
            return await self._hume_audio(audio_bytes)
        else:
            return self._fallback_result()

    async def analyze_text(self, text: str) -> Dict:
        """Detect emotion from text content."""
        if self.provider == "hume":
            return await self._hume_text(text)
        else:
            return await self._llm_emotion(text)

    async def _hume_audio(self, audio_bytes: bytes) -> Dict:
        try:
            import httpx

            url = "https://api.hume.ai/v0/batch/jobs"
            headers = {"X-Hume-Api-Key": self.settings.HUME_API_KEY}
            # Simplified — real implementation would upload and poll
            async with httpx.AsyncClient() as client:
                resp = await client.post(
                    url,
                    headers=headers,
                    files={"file": ("audio.wav", audio_bytes, "audio/wav")},
                    data={"models": '{"prosody": {}}'},
                    timeout=60,
                )
                resp.raise_for_status()
                # Parse response for top emotion
                return self._parse_hume_response(resp.json())
        except Exception as e:
            logger.error("Hume emotion error: %s", e)
            return self._fallback_result()

    async def _hume_text(self, text: str) -> Dict:
        try:
            import httpx

            url = "https://api.hume.ai/v0/batch/jobs"
            headers = {"X-Hume-Api-Key": self.settings.HUME_API_KEY}
            async with httpx.AsyncClient() as client:
                resp = await client.post(
                    url,
                    headers=headers,
                    json={"text": [text], "models": {"language": {}}},
                    timeout=60,
                )
                resp.raise_for_status()
                return self._parse_hume_response(resp.json())
        except Exception as e:
            logger.error("Hume text emotion error: %s", e)
            return await self._llm_emotion(text)

    async def _llm_emotion(self, text: str) -> Dict:
        """Fallback: use LLM to classify emotion."""
        from app.core.ai.factory import get_llm_client

        client = get_llm_client()
        result = await client.chat(
            messages=[
                {
                    "role": "system",
                    "content": "Classify the emotion in the user's text. Respond ONLY with a JSON: {\"primary_emotion\": \"...\", \"confidence\": 0.0-1.0, \"all_emotions\": {\"joy\": 0.1, ...}}",
                },
                {"role": "user", "content": text},
            ],
            temperature=0.1,
        )
        try:
            import json
            return json.loads(result["content"])
        except Exception:
            return self._fallback_result()

    @staticmethod
    def _parse_hume_response(data: dict) -> Dict:
        """Parse Hume API response into our standard format."""
        # Simplified parser
        return {
            "primary_emotion": "neutral",
            "confidence": 0.5,
            "all_emotions": {"neutral": 0.5},
        }

    @staticmethod
    def _fallback_result() -> Dict:
        return {
            "primary_emotion": "neutral",
            "confidence": 0.0,
            "all_emotions": {},
        }
